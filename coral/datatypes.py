from __future__ import annotations

import enum
from dataclasses import dataclass, field
from typing import (
    TYPE_CHECKING,
    Dict,
    Generic,
    NamedTuple,
    Set,
    TypeVar,
)

import pyomo.environ as pyo

from coral import types

if TYPE_CHECKING:
    from coral.breakpoint.breakpoint_graph import BreakpointGraph

T = TypeVar("T")


@dataclass
class EdgeToCN:
    """Container class for mapping edge indices (by type) to CN (copy number) values."""

    sequence: Dict[int, float] = field(default_factory=dict)
    concordant: Dict[int, float] = field(default_factory=dict)
    discordant: Dict[int, float] = field(default_factory=dict)
    source: Dict[int, float] = field(default_factory=dict)

    @staticmethod
    def from_graph(bp_graph: BreakpointGraph):
        return EdgeToCN(
            sequence={
                i: edge[-1] for i, edge in enumerate(bp_graph.sequence_edges)
            },
            concordant={
                i: edge[-1] for i, edge in enumerate(bp_graph.concordant_edges)
            },
            discordant={
                i: edge[-1] for i, edge in enumerate(bp_graph.discordant_edges)
            },
            source={
                i: edge[-1] for i, edge in enumerate(bp_graph.source_edges)
            },
        )


class WalkData(NamedTuple, Generic[T]):
    """Container for storing graph walk data, separated into cycles and paths."""

    cycles: list[T]
    paths: list[T]


@dataclass
class CycleSolution:
    """Container for storing MIQCP Pyomo solution state.

    This consists of parsing solved cycles, their weights, and corresponding
    satisfied path constraints.

    """

    solver_status: pyo.SolverStatus
    termination_condition: pyo.TerminationCondition
    total_weights_included: float = 0.0
    walks: WalkData[types.AmpliconWalk] = field(
        default_factory=lambda: WalkData([], [])
    )
    walk_weights: WalkData[float] = field(
        default_factory=lambda: WalkData([], [])
    )
    satisfied_pc: WalkData[list[int]] = field(
        default_factory=lambda: WalkData([], [])
    )  # Each list contains indices of satisfied path constraints for relevant walk.
    satisfied_pc_set: Set[int] = field(default_factory=set)

    @property
    def num_pc_satisfied(self) -> int:
        return len(self.satisfied_pc_set)

    @property
    def num_cycles(self) -> int:
        return len(self.walks.cycles)

    @property
    def num_paths(self) -> int:
        return len(self.walks.paths)


class InitialSolution(NamedTuple):
    """Container for storing initial solution state (generated by a heuristic method or incomplete solver run), to be passed to another model."""

    walks: WalkData[types.AmpliconWalk]
    walk_weights: WalkData[float]
    satisfied_pc: WalkData[list[int]]


class Solver(str, enum.Enum):
    """Enum for specifying the solver to pass to the MIQCP model used for cycle identification."""

    GUROBI = "gurobi"
    SCIP = "scip"
    # Coin-OR solvers
    BONMIN = "bonmin"
    COUENNE = "couenne"


@dataclass
class SolverOptions:
    num_threads: int = -1
    time_limit_s: int = 7200
    output_dir: str = "models"
    model_prefix: str = "pyomo"
    solver: Solver = Solver.GUROBI
