from __future__ import annotations

import enum
from dataclasses import dataclass, field
from typing import (
    TYPE_CHECKING,
    Dict,
    Generic,
    NamedTuple,
    Set,
    TypeVar,
)

import pyomo.environ as pyo

from coral import types

if TYPE_CHECKING:
    from coral.breakpoint.breakpoint_graph import BreakpointGraph

T = TypeVar("T")


@dataclass
class Interval:
    chr_tag: str
    start: int
    end: int
    amplicon_id: int = -1

    def __len__(self) -> int:
        return self.end - self.start + 1

    def does_overlap(self, other: Interval) -> bool:
        """Check if two chromosome intervals overlap (share a subsequence).

        Intervals are given in the form [chr, start, end], where:
            chr: chromosome number
            s: start position/index
            e: end position/index
        """
        return (
            self.chr_tag == other.chr_tag
            and self.start <= other.end
            and self.end >= other.start
        )

    def intersects(self, y: Interval, extend=0, margin=0.0) -> bool:
        if margin > 0.0:
            margin_offset = (1 - margin) * (y.end - y.start)
            margin_interval = (
                (y.start + margin_offset, y.end - margin_offset),
                (self.start + margin_offset, self.end - margin_offset),
            )

            for start, end in margin_interval:
                if (
                    self.chr_tag == y.chr_tag
                    and self.start <= end
                    and self.end >= start
                ):
                    return True
            return False

        # Adjust the intervals with the extension
        self_start, self_end = max(0, self.start - extend), self.end + extend
        n_start, n_end = y.start, y.end

        # Check for chromosome match and interval overlap
        if self.chr_tag != y.chr_tag:
            return False

        return self_start <= n_end and self_end >= n_start

    def intersection(self, y: Interval) -> Interval | None:
        if not self.intersects(y):
            return None
        return Interval(
            self.chr_tag, max(self.start, y.start), min(self.end, y.end)
        )

    def merge(self, y: Interval, extend=0) -> Interval | None:
        if not self.intersects(y, extend):
            return None
        return Interval(
            self.chr_tag, min(self.start, y.start), max(self.end, y.end)
        )


@dataclass
class EdgeToCN:
    """Container class for mapping edge indices (by type) to CN (copy number) values."""

    sequence: Dict[int, float] = field(default_factory=dict)
    concordant: Dict[int, float] = field(default_factory=dict)
    discordant: Dict[int, float] = field(default_factory=dict)
    source: Dict[int, float] = field(default_factory=dict)

    @staticmethod
    def from_graph(bp_graph: BreakpointGraph):
        return EdgeToCN(
            sequence={
                i: edge[-1] for i, edge in enumerate(bp_graph.sequence_edges)
            },
            concordant={
                i: edge[-1] for i, edge in enumerate(bp_graph.concordant_edges)
            },
            discordant={
                i: edge[-1] for i, edge in enumerate(bp_graph.discordant_edges)
            },
            source={
                i: edge[-1] for i, edge in enumerate(bp_graph.source_edges)
            },
        )


class WalkData(NamedTuple, Generic[T]):
    """Container for storing graph walk data, separated into cycles and paths."""

    cycles: list[T]
    paths: list[T]


@dataclass
class CycleSolution:
    """Container for storing MIQCP Pyomo solution state.

    This consists of parsing solved cycles, their weights, and corresponding
    satisfied path constraints.

    """

    solver_status: pyo.SolverStatus
    termination_condition: pyo.TerminationCondition
    total_weights_included: float = 0.0
    walks: WalkData[types.AmpliconWalk] = field(
        default_factory=lambda: WalkData([], [])
    )
    walk_weights: WalkData[float] = field(
        default_factory=lambda: WalkData([], [])
    )
    satisfied_pc: WalkData[list[int]] = field(
        default_factory=lambda: WalkData([], [])
    )  # Each list contains indices of satisfied path constraints for relevant walk.
    satisfied_pc_set: Set[int] = field(default_factory=set)

    @property
    def num_pc_satisfied(self) -> int:
        return len(self.satisfied_pc_set)

    @property
    def num_cycles(self) -> int:
        return len(self.walks.cycles)

    @property
    def num_paths(self) -> int:
        return len(self.walks.paths)


class InitialSolution(NamedTuple):
    """Container for storing initial solution state (generated by a heuristic method or incomplete solver run), to be passed to another model."""

    walks: WalkData[types.AmpliconWalk]
    walk_weights: WalkData[float]
    satisfied_pc: WalkData[list[int]]


class Solver(str, enum.Enum):
    """Enum for specifying the solver to pass to the MIQCP model used for cycle identification."""

    GUROBI = "gurobi"
    SCIP = "scip"
    # Coin-OR solvers
    BONMIN = "bonmin"
    COUENNE = "couenne"


@dataclass
class SolverOptions:
    num_threads: int = -1
    time_limit_s: int = 7200
    output_dir: str = "models"
    model_prefix: str = "pyomo"
    solver: Solver = Solver.GUROBI
