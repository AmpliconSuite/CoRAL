from __future__ import annotations

from dataclasses import dataclass

import numpy as np
import pandas as pd
import pandera as pa
import pandera.typing as pat


@dataclass
class OverallReconstructionStats:
    n_amplified_intervals: int = 0
    n_sequence_edges: int = 0
    n_breakpoint_edges: int = 0
    n_amplified_intervals_covered: int = 0
    n_sequence_edges_covered: int = 0
    n_breakpoint_edges_covered: int = 0
    n_reconstructed_sequence_edges_total: int = 0
    n_reconstructed_breakpoint_edges_total: int = 0
    fragment_overlap: float = 0
    reconstruction_length_ratio: float = 0
    cycle_triplets_correct: float = np.nan
    best_copy_number_ratio: float = 0
    top_three_copy_number_ratio: float = 0
    overall_max_lcs: float = 0
    overall_max_normalized_lcs: float = 0


@dataclass
class AmpliconReconstructionStats:
    n_overlapping_seq_edges: int = 0
    n_overlapping_bp_edges: int = 0
    n_reconstructed_sequence_edges_total: int = 0
    n_reconstructed_breakpoint_edges_total: int = 0
    fragment_overlap: float = 0
    reconstruction_length_ratio: float = 0
    cycle_triplets_correct: float = np.nan
    best_copy_number_ratio: float = 0
    top_three_copy_number_ratio: float = 0
    overall_max_lcs: float = 0
    overall_max_normalized_lcs: float = 0


class BinnedGenome(pa.DataFrameModel):
    chromosome: str
    start: int
    end: int


class SimulatedAmpliconSchema(pa.DataFrameModel):
    """
    Schema for simulated amplicon data generated by ecSimulator
        (https://github.com/AmpliconSuite/ecSimulator)

    Columns:
        type: The type of amplicon.
        breakpoints: The number of breakpoints in the amplicon.
        coverage: The coverage of the sequencing technique used for theamplicon.
        replicate: The replicate number.

    Example:
        chromothripsis  bp1     100x    amplicon2
        chromothripsis  bp10    250x    amplicon2
        foldback        bp20    50x     amplicon5
        episomal        bp20    250x    amplicon4
    """

    type: pat.Series[str]
    breakpoints: pat.Series[int]
    coverage: pat.Series[int]
    replicate: pat.Series[int]

    @pa.parser("breakpoints")
    def breakpoints_parser(
        self, breakpoints: pat.Series[str]
    ) -> pat.Series[int]:
        # Of the form 'bp<int>, e.g. 'bp1', 'bp100'
        return (
            breakpoints.astype(str)
            .str.extract(r"bp(\d+)")[0]
            .astype(int)
            .rename("breakpoints")
        )

    @pa.parser("coverage")
    def coverage_parser(self, coverage: pat.Series[str]) -> pat.Series[int]:
        # Of the form '<int>x', e.g. '10x', '100x'
        parsed_coverage = (
            coverage.astype(str).str.extract(r"(\d+)x")[0].astype(int)
        )
        parsed_coverage.name = "coverage"
        return parsed_coverage

    @pa.parser("replicate")
    def replicate_parser(self, replicate: pat.Series[str]) -> pat.Series[int]:
        # Of the form 'amplicon<int>', e.g. 'amplicon1', 'amplicon3'
        parsed_replicate = (
            replicate.astype(str).str.extract(r"amplicon(\d+)")[0].astype(int)
        )
        parsed_replicate.name = "replicate"
        return parsed_replicate
