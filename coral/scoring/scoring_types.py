from __future__ import annotations

from dataclasses import dataclass

import numpy as np
import pandas as pd
import pandera as pa
import pandera.typing as pat

from coral import datatypes


@dataclass
class TrueAmpliconStats:
    n_amplified_intervals: int = 0
    n_sequence_edges: int = 0
    n_breakpoint_edges: int = 0
    n_amplified_intervals_covered: int = 0
    n_sequence_edges_covered: int = 0
    n_breakpoint_edges_covered: int = 0
    n_reconstructed_sequence_edges_total: int = 0
    n_reconstructed_breakpoint_edges_total: int = 0
    fragment_overlap: float = 0
    reconstruction_length_ratio: float = 0
    cycle_triplets_correct: float = np.nan
    best_copy_number_ratio: float = 0
    top_three_copy_number_ratio: float = 0
    overall_max_lcs: float = 0
    overall_max_normalized_lcs: float = 0
    has_cycle_match: bool = False

    # Pulled from the reconstructed amplicon that best matches the true amplicon
    matched_amplicon: str | None = None
    model_used: datatypes.ModelType | None = None
    mip_gap: float | None = None


@dataclass
class ReconstructedAmpliconStats:
    n_overlapping_seq_edges: int = 0
    n_overlapping_bp_edges: int = 0
    n_reconstructed_sequence_edges_total: int = 0
    n_reconstructed_breakpoint_edges_total: int = 0
    fragment_overlap: float = 0
    reconstruction_length_ratio: float = 0
    cycle_triplets_correct: float = np.nan
    best_copy_number_ratio: float = 0
    top_three_copy_number_ratio: float = 0
    overall_max_lcs: float = 0
    overall_max_normalized_lcs: float = 0
    has_cycle_match: bool = False
    model_used: datatypes.ModelType | None = None
    mip_gap: float | None = None


class BinnedGenome(pa.DataFrameModel):
    chromosome: str
    start: int
    end: int


class ReconstructionScoreModel(pa.DataFrameModel):
    dataset: pat.Series[str]
    model: pat.Series[str]
    amplicon: pat.Series[str]
    coverage: pat.Series[int]
    n_breakpoints: pat.Series[int]

    # Below should match TrueAmpliconStats
    n_amplified_intervals: pat.Series[int]
    n_sequence_edges: pat.Series[int]
    n_breakpoint_edges: pat.Series[int]
    n_amplified_intervals_covered: pat.Series[int]
    n_sequence_edges_covered: pat.Series[int]
    n_breakpoint_edges_covered: pat.Series[int]
    n_reconstructed_sequence_edges_total: pat.Series[int]
    n_reconstructed_breakpoint_edges_total: pat.Series[int]
    fragment_overlap: pat.Series[float]
    reconstruction_length_ratio: pat.Series[float]
    cycle_triplets_correct: pat.Series[float]
    best_copy_number_ratio: pat.Series[float]
    top_three_copy_number_ratio: pat.Series[float]
    overall_max_lcs: pat.Series[float]
    overall_max_normalized_lcs: pat.Series[float]
    has_cycle_match: pat.Series[bool]

    # Pulled from the reconstructed amplicon that best matches the true amplicon
    matched_amplicon: pat.Series[str]
    model_used: pat.Series[str] = pa.Field(nullable=True)
    mip_gap: pat.Series[float] = pa.Field(nullable=True)


ReconstructionScoreSchema = ReconstructionScoreModel.to_schema()


class SimulatedAmpliconSchema(pa.DataFrameModel):
    """
    Schema for simulated amplicon data generated by ecSimulator
        (https://github.com/AmpliconSuite/ecSimulator)

    Columns:
        type: The type of amplicon.
        breakpoints: The number of breakpoints in the amplicon.
        coverage: The coverage of the sequencing technique used for theamplicon.
        replicate: The replicate number.

    Example:
        chromothripsis  bp1     100x    amplicon2
        chromothripsis  bp10    250x    amplicon2
        foldback        bp20    50x     amplicon5
        episomal        bp20    250x    amplicon4
    """

    type: pat.Series[str]
    breakpoints: pat.Series[int]
    coverage: pat.Series[int]
    replicate: pat.Series[int]

    @pa.parser("breakpoints")
    def breakpoints_parser(
        self, breakpoints: pat.Series[str]
    ) -> pat.Series[int]:
        # Of the form 'bp<int>, e.g. 'bp1', 'bp100'
        return (
            breakpoints.astype(str)
            .str.extract(r"bp(\d+)")[0]
            .astype(int)
            .rename("breakpoints")
        )

    @pa.parser("coverage")
    def coverage_parser(self, coverage: pat.Series[str]) -> pat.Series[int]:
        # Of the form '<int>x', e.g. '10x', '100x'
        parsed_coverage = (
            coverage.astype(str).str.extract(r"(\d+)x")[0].astype(int)
        )
        parsed_coverage.name = "coverage"
        return parsed_coverage

    @pa.parser("replicate")
    def replicate_parser(self, replicate: pat.Series[str]) -> pat.Series[int]:
        # Of the form 'amplicon<int>', e.g. 'amplicon1', 'amplicon3'
        parsed_replicate = (
            replicate.astype(str).str.extract(r"amplicon(\d+)")[0].astype(int)
        )
        parsed_replicate.name = "replicate"
        return parsed_replicate
